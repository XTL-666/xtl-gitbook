# 現代操作系統\(進程與線程\)

​

進程與線程

cpu：只能運行一個進程（某個瞬間）

進程模型

真正的cpu在各進程之間互相切換。--------&gt;多道程序設計

進程的創建

系統初始化

正在運行的程序執行了創建進程的系統調用

用戶請求創建一個新進程

一個批處理作業的初始化

UNIX：fork\(調用相同的副本）

進程創建之後，父進程與子進程有各自不同的地址空間。

進程的終止

正常退出

出錯退出

嚴重錯誤

被其他進程殺死

進程的層次結構

父進程與子進程以某種形式保持關聯，子進程自身可以創建更多的進程，組成一個進程的層次結構。

在UNIX中，進程和它的所有子進程以及後裔共同組成一個進程組，

整個系統中，所有進程都屬於可以init的爲根的一棵樹

windows，父進程通過所有句柄來控制子進程

進程的狀態：

運行

阻塞

就緒

進程因爲等待輸入被阻塞

調度程序選擇另一個進程

調度程序選擇此進程

出現有效輸入，阻塞狀態變成就緒狀態

理想狀態是調度程序位於操作系統的最底層

進程的實現

os維護着一張進程表（process table）

每一I/O類關聯的是中斷向量\(interrupt vector\)

中斷髮生後

os最底層的工作步驟

硬件壓入堆棧程序計數器

硬件從中斷向量裝入新的程序計數器

彙編語言過程保存寄存器值

彙編語言過程設置新的堆棧

C中斷服務例程運行

調度程序決定下一個將運行的進程

C過程返回至彙編代碼

彙編語言過程開始新的當前進程

CPU利用率 = 1-p的n次冪

其中，假設一個進程等待I/O操作時間與其停留在內存中的時間比例爲P

線程：迷你進程

必要性

使傳統設計模型變得簡單

並行實體擁有共享一個地址空間和所有可用數據的能力

線程與進程相比更輕量級

加快應用程序執行速度

經典的線程模型

每個線程中的內容

程序計數器

寄存器

堆棧

狀態

POSIX線程

用戶空間中實現線程

用戶空間

內核

用戶級別的線程包

線程切換至少比陷入內核快一個數量級

線程完成時，調用線程調度程序來選擇另一個要運行的線程，比內核調用效率更高

允許每個進程有自己定製的調度算法

問題

如何實現阻塞系統調用

不能用輪轉調度的方式調度進程

內核中實現

在內核中創建或撤銷線程的代價比較大，採取“環保”處理方式，回收其線程

混合實現

調度程序激活機制

模擬內核線程的功能，但爲線程包提供通常在用戶空間中才能實現的更好的性能與更大的靈活性

上行調用（upcall）

彈出式線程

使用之前，需要提前計劃

單線程代碼多線程話

引入新的庫過程，以便創建、設置、和讀取這些線程範圍的全局變量。

```text
create_global("buffptr");set_global("bufptr",&buf);bufptr= read_global("bufptr");
```

進程之間的通信

競爭條件

在一些os中，寫作進程可能共享一些彼此都能讀寫的公用存儲區

兩個或多個進程讀寫某些共享數據，最後結果取決於進程運行的精確時序，稱爲競爭條件

臨界區

避免競爭，需要互斥

好的解決方案

任何兩個進程不能同時處於其臨界區

不應對cpu的速度和數量做任何假設

臨界區外運行的進程不得阻塞其他進程

不得使進程無限期等待進入臨界區

忙等待的互斥

屏蔽中斷

對os有用，對於用戶進程則不是一種合適的通用互斥機制

鎖變量（會發生假脫機目錄一樣的疏漏）

嚴格輪換法

自旋鎖

peterson解法

一個進程在臨界區時，另一個進程無法進入

TSL指令

TSL RX，LOCK 測試並加鎖

執行TSL指令的cpu將鎖住捏村總線，以禁止其他CPU在本指令結束之前訪問內存

enter\_region:

TSL REGISITER,LOCK

CMP REGISTER,\#0

JNE enter\_region

leave\_region

MOVE LOCK, \# 0

RET

